/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */


/******************************************************************************
XRP7724 Command Library

The I2C Slave will support 2 modes of communication:
    (1) Standard
        Commands will be 8 bits long (with addresses less than 0x80) and data
        will be transmitted in word (16 bit) lengths.
    
    (2) Register
        Addresses represented in 16 bits but only transmit data in byte (8 bit)
        lengths. The High Byte of the register addresses will always be > 0x80.
    
The XRP7724 can support 4 types of commands:
    (1) System
        Monitor and manage the XRP7724, and interrupts and faults generated by
        it.
        
    (2) Power
        Control, monitor and adjust power parameters in a running
        system.
        
    (3) IO
        Control direction and polarity of GPIOs and PSIOs.
    
    (4) Flash
        Program customer configurations into NVM.
******************************************************************************/

#include "Arduino.h"
#include "PowerXR.h"
#include <Wire.h>

#define READ_VOLTAGE_CH_CONST 0.015
#define READ_VOLTAGE_VIN_CONST 0.0125
#define READ_TEMP_VTJ_CONST 5
#define SET_VOLTAGE_CH_CONST 0.0125
#define FLASH_RETRIES 3
#define FREQ_PLL 102000000

#define GET_REV_ID 0x01
#define GET_HOST_STS 0x02
#define SET_HOST_INT_MASK 0x03
#define CLEAR_HOST_INT 0x04
#define GET_FAULT_STS 0x05
#define CLEAR_FAULT_STS 0x06
#define PWR_GET_STATUS 0x09
#define PWR_CHIP_READY 0x0E
#define PWR_RESTART 0x0F
#define PWR_READ_VOLTAGE_CH1 0x10
#define PWR_READ_VOLTAGE_CH2 0x11
#define PWR_READ_VOLTAGE_CH3 0x12
#define PWR_READ_VOLTAGE_CH4 0x13
#define PWR_READ_VOLTAGE_VIN 0x14
#define PWR_READ_TEMP_VTJ 0x15
#define PWR_READ_CURRENT_CH1 0x16
#define PWR_READ_CURRENT_CH2 0x17
#define PWR_READ_CURRENT_CH3 0x18
#define PWR_READ_CURRENT_CH4 0x19
#define PWR_ENABLE_SUP_GROUP 0x1D
#define PWR_ENABLE_SUP 0x1E
#define PWR_SET_VOLTAGE_CH1 0x20
#define PWR_SET_VOLTAGE_CH2 0x21
#define PWR_SET_VOLTAGE_CH3 0x22
#define PWR_SET_VOLTAGE_CH4 0x23
#define PWR_SET_CURRENT_CH1 0x24
#define PWR_SET_CURRENT_CH2 0x25
#define PWR_SET_CURRENT_CH3 0x26
#define PWR_SET_CURRENT_CH4 0x27
#define PWR_POWER_OK_CFG 0x2A
#define GPIO_READ_GPIO 0x30
#define GPIO_SET_GPIO 0x31
#define GPIO_POL_GPIO 0x32
#define FLASH_PROGRAM_ADDRESS 0x40
#define FLASH_PROGRAM_DATA 0x41
#define FLASH_PROGRAM_DATA_INC_ADDR 0x42
#define FLASH_INIT 0x4D
#define FLASH_PAGE_CLEAR 0x4E
#define FLASH_PAGE_ERASE 0x4F

#define HW_ID_XRP7724 0x1203
#define TRIM_ID_XRP7724 0x00
#define TRIM_ID_XRP7725 0x01
#define TRIM_ID_XRP7720 0x02
#define TRIM_ID_XRP9711 0x03
#define TRIM_ID_XRP9710 0x04

#define TRIMVERSION 0x8060
#define HW_DYN_PRESCALER_CH0 0xC03D
#define HW_COUNTER_RESTART_STATE_UPPER 0xC40A
#define HW_COUNTER_RESTART_STATE_LOWER 0xC40B
#define HW_FREQUENCY_TIER 0xC40C
#define HW_ISENSE_IFE_GAIN8_ENABLE 0xD016
#define HW_STOP_CLK 0xFFB3
#define READ_POWER_GOOD 0xD512
#define I2CS_ADDR 0xFFB7
#define I2CSADDR  0x8074      

#define TOTAL_NUM_OF_RECS 39 // number of records(lines) in the runtime hex file, excluding the End of File record 

//<<default constructor>>
Xrp7724::Xrp7724(){
    /*nothing to construct*/
}

//<<constructor>>
Xrp7724::Xrp7724(int i2c_addr){
    _i2c_addr = i2c_addr;
}

//<<destructor>>
Xrp7724::~Xrp7724(){    
    /*nothing to destruct*/    
}

word Xrp7724::standard_read(byte address) {
    word data = 0xFFFF;
  
    // send register address
    Wire.beginTransmission(_i2c_addr);
    Wire.write(address);
    Wire.endTransmission();
  
    // request two bytes
    if (Wire.requestFrom(_i2c_addr, 2) == 2) {
        data = Wire.read() << 8;
        data |= Wire.read();
    }
  
    return data;
}

void Xrp7724::standard_write(byte address, word data) {
    // send register address
    Wire.beginTransmission(_i2c_addr);
    Wire.write(address);
    
    // send two bytes
    Wire.write(highByte(data));
    Wire.write(lowByte(data));
    Wire.endTransmission();
}

byte Xrp7724::register_read(word address) {
    byte data = 0xFF;
  
    // send register address
    Wire.beginTransmission(_i2c_addr);
    Wire.write(highByte(address));
    Wire.write(lowByte(address));
    Wire.endTransmission();
    
    // request one byte
    if (Wire.requestFrom(_i2c_addr, 1) == 1) {
        data = Wire.read();
    }
  
    return data;
}

void Xrp7724::register_write(word address, byte data) {
    // send register address
    Wire.beginTransmission(_i2c_addr);
    Wire.write(highByte(address));
    Wire.write(lowByte(address));
    
    // send one byte
    Wire.write(data);
    Wire.endTransmission();
}

/*=============================================================================
(1) System Commands
=============================================================================*/

/*-----------------------------------------------------------------------------
    String get_chip_name();
    GET_REV_ID: 0x01
    Report the chip name.
-----------------------------------------------------------------------------*/
String Xrp7724::get_chip_name() {
    word rev_id = standard_read(GET_REV_ID);
    word trim_id = register_read(TRIMVERSION);
    String name;
    name = String(trim_id);
    
    if (rev_id == HW_ID_XRP7724) {
        if (trim_id == TRIM_ID_XRP7724) {
            name = "XRP7724";
        }
        else if (trim_id == TRIM_ID_XRP7725) {
            name = "XRP7725";
        }
        else if (trim_id == TRIM_ID_XRP7720) {
            name = "XRP7720";
        }
        else if (trim_id == TRIM_ID_XRP9711) {
            name = "XRP9711";
        }
        else if (trim_id == TRIM_ID_XRP9710) {
            name = "XRP9710";
        }
        else {
            name = "No Trim ID";
        }
    }
    else {
        name = "No Rev ID";
    }
    
    return name;
}

/*-----------------------------------------------------------------------------
    word get_host_status();
    GET_HOST_STS: 0x02
    Report the status of the Interrupt Status Register. With this command, the
    host will determine the cause of the interrupt.

    InterruptStatus register
    [0] - GPIO_EVENT
    [1] - SUPPLY_FAULT_EVENT
    [2] - TEMP_OVER_EVENT
    [3] - TEMP_UNDER_EVENT
    [4] - RESERVED
    [5] - UVLO_FAULT_ACTIVE_EVENT
    [6] - UVLO_FAULT_INACTIVE_EVENT
    [7] - UVLO_WARNING_EVENT
    [8] - FLASH_CLEAR_DONE_EVENT
    [9] - FLASH_ERASE_DONE_EVENT
    [10] - RESERVED
    [11] - V5EXT_RISE_EVENT
    [12] - V5EXT_FALL_EVENT
    [13] - LDOAOVC_EVENT
-----------------------------------------------------------------------------*/
word Xrp7724::get_host_status() {
    return standard_read(GET_HOST_STS);
}

/*-----------------------------------------------------------------------------
    void set_host_int_mask(word);
    SET_HOST_INT_MASK: 0x03
    Set interrupt mask. Only unmasked interrupts will be reported in the
    Interrupt Pin.
-----------------------------------------------------------------------------*/
void Xrp7724::set_host_int_mask(word interrupt_enable) {
    standard_write(SET_HOST_INT_MASK, interrupt_enable);
}

/*-----------------------------------------------------------------------------
    void clear_host_int(word);
    CLEAR_HOST_INT: 0x04
    Clear interrupts. An interrupt will be reported by the Interrupt Pin until
    the host clears it using this command.
-----------------------------------------------------------------------------*/
void Xrp7724::clear_host_int(word interrupt_status) {
    standard_write(CLEAR_HOST_INT, interrupt_status);
}

/*-----------------------------------------------------------------------------
    word get_fault_status();
    GET_FAULT_STS: 0x05
    Reports if channels are in OCP or OVP faults, and if 3.3 LDO is in
    regulation or in OVC fault.
    
    fault_status register
    [0] - CH1 OCP
    [1] - CH2 OCP
    [2] - CH3 OCP
    [3] - CH4 OCP
    [4] - CH1 OVP
    [5] - CH2 OVP
    [6] - CH3 OVP
    [7] - CH4 OVP
    [8] - LDO OVC
    [9] - LDO OK
-----------------------------------------------------------------------------*/
word Xrp7724::get_fault_status() {
    return standard_read(GET_FAULT_STS);
}

/*-----------------------------------------------------------------------------
    void clear_fault_status(word);
    CLEAR_FAULT_STS: 0x06
    Clear faults. A fault will be reported by the FaultStatus register until
    the host clears it using this command.
-----------------------------------------------------------------------------*/
void Xrp7724::clear_fault_status(word fault_status) {
    return standard_write(CLEAR_FAULT_STS, fault_status);
}

/*-----------------------------------------------------------------------------
    word power_get_status();
    PWR_GET_STATUS: 0x09
    Report supply status; whether it is in regulation or in fault.
    
    supply_status register
    supply_fault_map
    [0] - CH1 Fault
    [1] - CH2 Fault
    [2] - CH3 Fault
    [3] - CH4 Fault
    [4] - LDO Fault
    supply_inreg_map
    [0] - CH1 Inreg
    [1] - CH2 Inreg
    [2] - CH3 Inreg
    [3] - CH4 Inreg
    [4] - LDO Inreg
-----------------------------------------------------------------------------*/
word Xrp7724::power_get_status() {
    return standard_read(PWR_GET_STATUS);
}

/*-----------------------------------------------------------------------------
    byte get_power_chip_ready();
    GET_PWR_CHIP_READY: 0x0E
    Report whether the XRP7724 is in configuration or regulaton mode of
    operation.
    
    chip_ready register
    [0] - Configuration mode
    [1] - Regulation mode
-----------------------------------------------------------------------------*/
byte Xrp7724::get_power_chip_ready() {
    return standard_read(PWR_CHIP_READY);
}

/*-----------------------------------------------------------------------------
    void set_power_chip_ready(word);
    SET_PWR_CHIP_READY: 0x0E
    Control whether the XRP7724 is in configuration or regulaton mode of
    operation.
    
    chip_ready register
    [0] - Configuration mode
    [1] - Regulation mode
-----------------------------------------------------------------------------*/
void Xrp7724::set_power_chip_ready(word chip_ready) {
    standard_write(PWR_CHIP_READY, chip_ready & 0x0001);
}

/*-----------------------------------------------------------------------------
    void power_restart();
    PWR_RESTART: 0x0F
    Perform orderly shutdown and restart. This command will not ACK. After the
    command is sent, the device will not be available for about 50ms.
-----------------------------------------------------------------------------*/
void Xrp7724::power_restart() {
    standard_write(PWR_RESTART, 0x0F00);
}

/*-----------------------------------------------------------------------------
    void chip_reset();
    Issue FW_SOFT_RESET.
-----------------------------------------------------------------------------*/
void Xrp7724::chip_reset() {
    register_write(HW_STOP_CLK, 0x08);
}

/*=============================================================================
(2) Power Commands
=============================================================================*/

/*-----------------------------------------------------------------------------
    float power_read_voltage_ch(byte);
    PWR_READ_VOLTAGE_CHx: 0x10-0x13
    Report Vout value read from AUX ADC and adjusted by voltage range prescale
    factor.
-----------------------------------------------------------------------------*/
float Xrp7724::power_read_voltage_ch(byte channel) {
    return standard_read(PWR_READ_VOLTAGE_CH1 + channel)*READ_VOLTAGE_CH_CONST;
}

/*-----------------------------------------------------------------------------
    float power_read_voltage_vin();
    PWR_READ_VOLTAGE_VIN: 0x14
    Report Vcc value read from AUX ADC.
-----------------------------------------------------------------------------*/
float Xrp7724::power_read_voltage_vin() {
    return standard_read(PWR_READ_VOLTAGE_VIN)*READ_VOLTAGE_VIN_CONST;
}

/*-----------------------------------------------------------------------------
    int power_read_temp_vtj();
    PWR_READ_TEMP_VTJ: 0x15
    Report Vtj value read from AUX ADC.
-----------------------------------------------------------------------------*/
word Xrp7724::power_read_temp_vtj() {
    //word temp = (((standard_read(0x15)*0.010)-0.6)/0.002)+300;
    return standard_read(PWR_READ_TEMP_VTJ)*READ_TEMP_VTJ_CONST;
}

/*-----------------------------------------------------------------------------
    float power_read_lowside_voltage_ch(byte);
    PWR_READ_CURRENT_CHx: 0x16-0x19
    Report voltage value across the synchronous FET read from AUX ADC.
-----------------------------------------------------------------------------*/
float Xrp7724::power_read_lowside_voltage_ch(byte channel) {
    word voltage = standard_read(PWR_READ_CURRENT_CH1 + channel);
    float value = ((voltage * 0.01)/get_ife_gain(channel)) - 0.04;
    return value;
}

/*-----------------------------------------------------------------------------
    float get_ife_gain(byte);
    Report IFE gain.
-----------------------------------------------------------------------------*/
byte Xrp7724::get_ife_gain(byte channel) {
    byte gain8 = (register_read(HW_ISENSE_IFE_GAIN8_ENABLE) & (1 << channel)) >> channel;
    byte ife_gain = 0x4 << gain8;    
    return ife_gain;
}

/*-----------------------------------------------------------------------------
    float get_current_ch(byte channel, float ripple, float rds_on);
    Report channel current reading.
-----------------------------------------------------------------------------*/
float Xrp7724::get_current_ch(byte channel, float ripple, float rds_on) {
    float lowside = power_read_lowside_voltage_ch(channel);
    float current = max(0.0, ((lowside/rds_on) + ripple/2));
    return current;
}

/*-----------------------------------------------------------------------------
    void power_enable_supply_group(byte, byte);
    PWR_ENABLE_SUP_GROUP: 0x1D
    Turn supply groups on/off. The first byte specifies the group, the second
    whether to enable or disable it. There needs to be one command per group.
    If a group is turned on, its members can be turned off individually using
    the 'power_enable_supply' command. However, the group must be turned off
    first before a new group turn on command is serviced.
    
    enable
    0 = Disable
    1 = Enable
    
    supply_group
    0 = PWREN0
    1 = PWREN1
    2 = PWREN2
-----------------------------------------------------------------------------*/
void Xrp7724::power_enable_supply_group(byte supply_group, byte enable) {
    word data = (supply_group << 8) + enable;
    standard_write(PWR_ENABLE_SUP_GROUP, data);
}

/*-----------------------------------------------------------------------------
    void power_enable_supply(byte, byte);
    PWR_ENABLE_SUP: 0x1E
    Turn channels and 3.3 LDO on/off individually. There needs to be one
    command per supply.
    
    enable
    0 = Disable
    1 = Enable
    
    supply
    0 = CH1
    1 = CH2
    2 = CH3
    3 = CH4
    4 = 3.3 LDO
-----------------------------------------------------------------------------*/
void Xrp7724::power_enable_supply(byte supply, byte enable) {
    word data = (supply << 8) + enable;
    standard_write(PWR_ENABLE_SUP, data);
}

/*-----------------------------------------------------------------------------
    void power_set_voltage_ch(byte, float);
    PWR_SET_VOLTAGE_CHx: 0x20-0x23
    Change output voltage settings dynamically. The set voltage level maintains
    the same prescale voltage factor as in the original configuration and
    therefore, the same set point resolution. It is also possible to change the
    output voltage in fine set point resolution if desired using the command.
    
    fine_adj[15:12], set_value[11:0] (5.5v or 0x1B8 is max value)
-----------------------------------------------------------------------------*/
void Xrp7724::power_set_voltage_ch(byte channel, float set_value) {
    float prescale = get_prescale_voltage(channel);
    float vref = word( float(set_value) / (prescale * 5) + 0.000001 ) * (prescale * 5);
    word fine_adj = min(word(round((float(set_value) - vref) / prescale)), 0xF);
    word vref_value = min(word( (float(set_value)/SET_VOLTAGE_CH_CONST) + 0.000001 ), 0x1B8);
    standard_write((PWR_SET_VOLTAGE_CH1 + channel), (fine_adj << 12) + vref_value);
}


/*-----------------------------------------------------------------------------
    float get_prescale_voltage(byte);
    Report IFE gain.
-----------------------------------------------------------------------------*/
float Xrp7724::get_prescale_voltage(byte channel) {
    float voltage = 0.0;
    byte prescale = (register_read(HW_DYN_PRESCALER_CH0 + (channel * 0x100)) & 0x30) >> 4;
    switch (prescale) {
        case 0: voltage = 0.0025; break;
        case 1: voltage = 0.0050; break;
        case 2: voltage = 0.0100; break;
        default: voltage = 0.0;
    }
    return voltage;
}

/*-----------------------------------------------------------------------------
    void power_set_current_ch(byte, float, float);
    PWR_SET_CURRENT_CHx: 0x24-0x27
    Change channel OCP fault and warning levels dynamically.
    warning_value[11:9], fault_value[8:0]
-----------------------------------------------------------------------------*/
void Xrp7724::power_set_current_ch(byte channel, float warning_value, float fault_value) {
    word warning_set_value = word((get_ife_gain(channel) * (0.040 + warning_value)) / 0.01);
    word fault_set_value = word((get_ife_gain(channel) * (0.040 + fault_value)) / 0.01);
    word data = (warning_set_value << 8) + fault_set_value;
    standard_write((PWR_SET_CURRENT_CH1 + channel), data);
}

/*-----------------------------------------------------------------------------
    void power_ok_cfg(byte, byte);
    PWR_POWER_OK_CFG: 0x2A
    Include/exclude selected channel(s) or 3.3 LDO to/from Power OK pool
    dynamically.
    
    [0] - LDO 3.3
    
    [8] - CH1
    [9] - CH2
    [10] - CH3
    [11] - CH4
-----------------------------------------------------------------------------*/
void Xrp7724::power_ok_cfg(byte channel, byte ldo) {
    word data = (channel << 8) + ldo;
    standard_write(PWR_POWER_OK_CFG, data);
}

/*=============================================================================
(3) IO Commands
=============================================================================*/

/*-----------------------------------------------------------------------------
    byte read_gpio();
    GPIO_READ_GPIO: 0x30
    Read GPIO/PSIO pin value.
    
    io pin
    [0] - GPIO0
    [1] - GPIO1
    [2] - PSIO0
    [3] - PSIO1
    [4] - PSIO2
-----------------------------------------------------------------------------*/
byte Xrp7724::read_gpio() {
    return standard_read(GPIO_READ_GPIO);
}

/*-----------------------------------------------------------------------------
    void set_gpio(byte, byte);
    GPIO_SET_GPIO: 0x31
    Set GPIO/PSIO pin value when it is configured as an output.
    
    value
    0 = Set 0
    1 = Set 1
    
    io pin
    0 = GPIO0
    1 = GPIO1
    2 = PSIO0
    3 = PSIO1
    4 = PSIO2
-----------------------------------------------------------------------------*/
void Xrp7724::set_gpio(byte gpio_num, byte value) {
    word data = (gpio_num << 8) + value;    
    standard_write(GPIO_SET_GPIO, data);
}

/*-----------------------------------------------------------------------------
    void polarity_gpio(byte, byte);
    GPIO_POL_GPIO: 0x32
    Set polarity of GPIO/PSIO.
    
    Value
    0 = No invert
    1 = Invert
    
    IO Pin
    0 = GPIO0
    1 = GPIO1
    2 = PSIO0
    3 = PSIO1
    4 = PSIO2
-----------------------------------------------------------------------------*/
void Xrp7724::polarity_gpio(byte gpio_num, byte value) {
    word data = (gpio_num << 8) + value;
    standard_write(GPIO_POL_GPIO, data);
}

/*=============================================================================
(4) Flash Commands
=============================================================================*/

/*-----------------------------------------------------------------------------
    int get_flash_program_address();
    GET_FLASH_PROGRAM_ADDRESS: 0x40
-----------------------------------------------------------------------------*/
word Xrp7724::get_flash_program_address() {
    return standard_read(FLASH_PROGRAM_ADDRESS);
}

/*-----------------------------------------------------------------------------
    void set_flash_program_address(int);
    SET_FLASH_PROGRAM_ADDRESS: 0x40
-----------------------------------------------------------------------------*/
void Xrp7724::set_flash_program_address(word flash_address) {
    standard_write(FLASH_PROGRAM_ADDRESS, flash_address);
}

/*-----------------------------------------------------------------------------
    int get_flash_program_data();
    GET_FLASH_PROGRAM_DATA: 0x41
-----------------------------------------------------------------------------*/
word Xrp7724::get_flash_program_data() {
    return standard_read(FLASH_PROGRAM_DATA);
}

/*-----------------------------------------------------------------------------
    void set_flash_program_data(int);
    SET_FLASH_PROGRAM_DATA: 0x41
-----------------------------------------------------------------------------*/
void Xrp7724::set_flash_program_data(word data) {
    standard_write(FLASH_PROGRAM_DATA, data);
}

/*-----------------------------------------------------------------------------
    int get_flash_program_data_inc_addr();
    GET_FLASH_PROGRAM_DATA_INC_ADDR: 0x42
-----------------------------------------------------------------------------*/
word Xrp7724::get_flash_program_data_inc_addr() {
    return standard_read(FLASH_PROGRAM_DATA_INC_ADDR);
}

/*-----------------------------------------------------------------------------
    void set_flash_program_data_inc_addr(int);
    SET_FLASH_PROGRAM_DATA_INC_ADDR: 0x42
-----------------------------------------------------------------------------*/
void Xrp7724::set_flash_program_data_inc_addr(word data) {
    standard_write(FLASH_PROGRAM_DATA_INC_ADDR, data);
}

/*-----------------------------------------------------------------------------
    void flash_init(int);
    FLASH_INIT: 0x4D
-----------------------------------------------------------------------------*/
void Xrp7724::flash_init(word data) {
    standard_write(FLASH_INIT, data & 0x0007);
}

/*-----------------------------------------------------------------------------
    int get_flash_page_clear();
    GET_FLASH_PAGE_CLEAR: 0x4E
-----------------------------------------------------------------------------*/
word Xrp7724::get_flash_page_clear() {
    return standard_read(FLASH_PAGE_CLEAR);
}

/*-----------------------------------------------------------------------------
    void set_flash_page_clear(int, int);
    SET_FLASH_PAGE_CLEAR: 0x4E
-----------------------------------------------------------------------------*/
void Xrp7724::set_flash_page_clear(byte flash_page_clear_status, byte flash_page_clear_start) {
    word data = (flash_page_clear_status << 8) + flash_page_clear_start;
    standard_write(FLASH_PAGE_CLEAR, data);
}

/*-----------------------------------------------------------------------------
    int get_flash_page_erase();
    GET_FLASH_PAGE_ERASE: 0x4F
-----------------------------------------------------------------------------*/
word Xrp7724::get_flash_page_erase() {
    return standard_read(FLASH_PAGE_ERASE);
}

/*-----------------------------------------------------------------------------
    void set_flash_page_erase(int, int);
    SET_FLASH_PAGE_ERASE: 0x4F
-----------------------------------------------------------------------------*/
void Xrp7724::set_flash_page_erase(byte flash_page_erase_status, byte flash_page_erase_start) {
    word data = (flash_page_erase_status << 8) + flash_page_erase_start;
    standard_write(FLASH_PAGE_ERASE, data);
}

/*-----------------------------------------------------------------------------
    int clear_flash_page(int);
    function to clear flash page no. passed as argument
-----------------------------------------------------------------------------*/
byte Xrp7724::clear_flash_page(byte page) {
    byte num_retries = -1;
    word flash_page_clear_value = 1;
    byte count_clear = 0;

    flash_init(1);
    delay(50);
    
    for(byte i = 0; i < 3; i++){ // executing the outer loop just 3 times
        set_flash_page_clear(0x00, page); // flash_page_clear_status always 0x00
        delay(500);
        count_clear = 0;
        flash_page_clear_value  = get_flash_page_clear();

        while(flash_page_clear_value & 0xFF){  // means in progress
            count_clear++;
            if(count_clear > 10){
                Serial.print("Couldn't Clear, Page ");
                Serial.println(page);
                break;
            }
            delay(10);
            flash_page_clear_value = get_flash_page_clear();
        }
        
        num_retries = lowByte(flash_page_clear_value);
        delay(10);
        if(count_clear <= 10 && num_retries <= 0xFE)
            return 0;
    }
    return 1; // error condition - couldn't clear page
}

/*-----------------------------------------------------------------------------
    int erase_flash_page(int);
    function to erase flash page no. passed as argument
-----------------------------------------------------------------------------*/
byte Xrp7724::erase_flash_page(byte page) {
    byte num_retries = -1;
    word flash_page_erase_value = 1;
    byte count_erase = 0;


    flash_init(5);
    delay(50);

    
    for(byte i = 0; i < 3; i++){ // executing the outer loop just 3 times
        set_flash_page_erase(0x00, page); // flash_page_erase_status always 0x00
        delay(500);
        count_erase = 0;
        flash_page_erase_value  = get_flash_page_erase();

        while(flash_page_erase_value & 0xFF){  // means in progress
            count_erase++;
            if(count_erase > 10){
                Serial.print("Couldn't Erase, Page ");
                Serial.println(page);
                break;
            }
            delay(50);
            flash_page_erase_value = get_flash_page_erase();
        }

        num_retries = lowByte(flash_page_erase_value);
        delay(10);
        if(count_erase <= 10 && num_retries <= 0xFE)
            return 0;
    }
    return 1; // error condition - couldn't erase page
}

/*-----------------------------------------------------------------------------
    void program_flash(byte[], word);
    function to program flash based on an array of integers with consecutive values as addresses and values
-----------------------------------------------------------------------------*/
byte Xrp7724::program_flash(byte data[], word length){
    for(byte page = 0; page < 7; page++){
        word starting_page_addr = page * 64;
        byte erase_ret_val = -1;

        //clear page
        Serial.print("Clearing Page ");
        Serial.println(page);
        if(clear_flash_page(page))
            return 1;


        //erase page
        Serial.print("Erasing Page ");
        Serial.println(page);
        if(erase_flash_page(page))
            return 1;
        


        //write page
        flash_init(1);
        delay(10);
        set_flash_program_address(starting_page_addr);
        delay(10);
        Serial.print("Programming Page: ");
        Serial.println(page);
        word programmed_val = 0;
        word read_back_val = 0;
        for(word i = starting_page_addr; (i < length) && (i < (starting_page_addr + 64)); i+=2){
            programmed_val  = ((data[i]<<8)|data[i+1]);
            set_flash_program_data(programmed_val);
            delay(10);
            read_back_val = get_flash_program_data_inc_addr();
            delay(10);
            if(programmed_val != read_back_val ){ 
                Serial.println("Error, flash data not programmed correctly");
                Serial.print("Programmed Value: ");
                Serial.println(programmed_val);
                Serial.print("Read Back Value: ");
                Serial.println(read_back_val);
                Serial.print("Address: ");
                Serial.println(i);
                return 1;
            }
        }

    }
    flash_init(0);
    delay(10);
    Serial.println("Programming Completed");
    return 0;
}

/*-----------------------------------------------------------------------------
    void invalidate_flash();
    function to invalidate the flash, needed before ram download
-----------------------------------------------------------------------------*/
void Xrp7724::invalidate_flash(){
    byte invalidate_check = 0;
    word genctrl_crc_page5 = 0x017E;

    flash_init(1);
    delay(10);
    set_flash_program_address(genctrl_crc_page5); // set address to read CRC byte to check for valid config in flash
    delay(10);
    invalidate_check = get_flash_program_data_inc_addr() & 0xFFFF; // read CRC byte to check for valid config in flash
    delay(10);

    // clear the CRC byte if it is not cleared or erased
    if(!(invalidate_check == 0x0000) || (invalidate_check == 0xFFFF)){ 
        set_flash_program_address(genctrl_crc_page5); // set address to GenCtrl page 5 CRC byte
        delay(10);
        set_flash_program_data(0x0000); // invalidate config by clearing the CRC byte
        delay(10);
    }

    power_restart(); // soft reset
    delay(500);

    _i2c_addr = 0x28; // change address to default I2C address because there is no valid programmed config in the chip
}

/*-----------------------------------------------------------------------------
    void download_ram(byte[]);
    function to download the RAM image (one record at a time)
    each record sent as data[]
    data[0] - no of data bytes
    data[1] - Upper byte of starting address
    data[2] - Lower byte of starting address
    data[3] onwards - data bytes that are part of the record
-----------------------------------------------------------------------------*/
byte Xrp7724::download_ram(byte data[]){
    static byte num_recs_downloaded = 0; // to keep track of number of records(lines) from the runtime hex file downloaded so far
    word random_register = 0x8000;
    word random_value = 0x42;
    word reseved_register = 0xD022; // register used for internal purposes; should not be programmed
    byte num_bytes_in_rec = 0; 
    byte starting_addr_rec = 0x00;
    word reg_addr = 0x0000;
    byte reg_data = 0x00;
    byte readback_val = 0x00;
    byte ram_dump_fail_flag = 0;
    byte i2c_slave_addr_reg = 0;


    register_write(random_register, random_value); // assigning a value to a runtime register to verify at the end that the 
    delay(10);                                     // chip didn't reset while dowloading, refer to ANP-39

    // read the bytes coming in from the runtime hex file
    // this section is written assuming the number of bytes and starting address are sent before the actual data bytes in each record
    // each record sent as data[]
    // data[0] - no of data bytes
    // data[1] - Upper byte of starting address
    // data[2] - Lower byte of starting address
    // data[3] onwards - data bytes that are part of the record
    num_bytes_in_rec = data[0];
    starting_addr_rec = ((data[1] << 8) | data[2]) & 0xFFFF;
    for(byte i = 0; i < num_bytes_in_rec; i++){
        reg_addr = starting_addr_rec + i;
        reg_data = data[3+i];
        if(reg_addr != reseved_register){
            register_write(reg_addr, reg_data);
            delay(10);
            readback_val = register_read(reg_addr);
            delay(10);
            if(readback_val != reg_data){
                ram_dump_fail_flag = 1;
                break; 
            }
        }  
    }

    if(register_read(random_register) != random_value){
        Serial.println("Error, Chip reset while downloading");
        return 1;
    }
    if(ram_dump_fail_flag){
        Serial.println("Error, data not written to RAM correctly");
        Serial.print("Written Value: ");
        Serial.println(reg_data);
        Serial.print("Read Back Value: ");
        Serial.println(readback_val);
        Serial.print("Address: ");
        Serial.println(reg_addr);
        return 1;
    }
    else{
        num_recs_downloaded++;
        if(num_recs_downloaded == TOTAL_NUM_OF_RECS){
            Serial.println("RAM image downloaded successfully");
        }
    }

    set_power_chip_ready(0x0001); // set chip ready high
    delay(10);
    // Value from the I2CSADDR register needs to be written to I2CS_ADDR register at the end of RAM programming cycle
    i2c_slave_addr_reg = register_read(I2CSADDR);
    delay(10);
    register_write(I2CS_ADDR, i2c_slave_addr_reg); // setting the I2CS_ADDR register
    delay(10);
    return 0;   
}